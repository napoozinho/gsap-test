{"version":3,"file":"split-text-3Ia1marr.js","sources":["../node_modules/gsap/SplitText.js","../src/components/split-text.js"],"sourcesContent":["/*!\n * SplitText 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\n * @author: Jack Doyle\n */\n\nlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\n}, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\n  if (specialCharsRegEx) {\n    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\n    if (charsFound.size) {\n      while (--i > -1) {\n        word = collection[i];\n        for (char of charsFound) {\n          if (char.startsWith(word) && char.length > word.length) {\n            slots = 0;\n            combined = word;\n            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\n            }\n            if (slots && combined.length === char.length) {\n              collection[i] = char;\n              collection.splice(i + 1, slots);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return collection;\n}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\n  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\n    let el = document.createElement(tag), i = collection.length + 1;\n    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\n    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\n    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\n    if (tag !== \"span\") {\n      el.style.position = \"relative\";\n      el.style.display = display;\n    }\n    el.textContent = text;\n    collection.push(el);\n    return el;\n  };\n  incrementClass && (className = className.replace(\"++\", \"\"));\n  wrapper.collection = collection;\n  return wrapper;\n}, _getLineWrapper = (element, nodes, config, collection) => {\n  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\n  return (startIndex, endIndex) => {\n    let newLine = lineWrapper(\"\");\n    newLine.style.textAlign = textAlign;\n    element.insertBefore(newLine, nodes[startIndex]);\n    for (; startIndex < endIndex; startIndex++) {\n      newLine.appendChild(nodes[startIndex]);\n    }\n    newLine.normalize();\n  };\n}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\n  var _a;\n  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\n  if (typeof wordDelimiter === \"object\") {\n    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\n    wordDelimString = wordDelimiter.replaceWith || \"\";\n  } else {\n    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\n  }\n  wordDelimIsNotSpace = wordDelimString !== \" \";\n  for (; i < nodes.length; i++) {\n    curNode = nodes[i];\n    if (curNode.nodeType === 3) {\n      curTextContent = curNode.textContent || \"\";\n      if (reduceWhiteSpace) {\n        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\n      } else if (isPreformatted) {\n        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\n      }\n      prepareText && (curTextContent = prepareText(curTextContent, element));\n      curNode.textContent = curTextContent;\n      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\n      lastWordText = words[words.length - 1];\n      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\n      lastWordText || words.pop();\n      lastBounds = elementBounds;\n      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\n      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\n      words[0] || words.shift();\n      _stretchToFitSpecialChars(words, specialCharsRegEx);\n      deepSlice && isNested || (curNode.textContent = \"\");\n      for (j = 1; j <= words.length; j++) {\n        wordText = words[j - 1];\n        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\n          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\n          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\n          wordText = wordText.slice(1);\n        }\n        if (!reduceWhiteSpace && wordText === \"\") {\n          _insertNodeBefore(wordDelimString, element, curNode);\n        } else if (wordText === \" \") {\n          element.insertBefore(document.createTextNode(\" \"), curNode);\n        } else {\n          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\n          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\n            curWordEl = wordsCollection[wordsCollection.length - 1];\n            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\n          } else {\n            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\n            _insertNodeBefore(curWordEl, element, curNode);\n            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\n          }\n          if (charWrapper) {\n            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\n            for (k = 0; k < curWordChars.length; k++) {\n              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\n            }\n          }\n          if (deepSlice && isNested) {\n            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\n            bounds = curWordEl.getBoundingClientRect();\n            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\n              clonedNode = element.cloneNode();\n              curSubNode = element.childNodes[0];\n              while (curSubNode && curSubNode !== curWordEl) {\n                tempSubNode = curSubNode;\n                curSubNode = curSubNode.nextSibling;\n                clonedNode.appendChild(tempSubNode);\n              }\n              element.parentNode.insertBefore(clonedNode, element);\n              prepForCharsOnly && _disallowInline(clonedNode);\n            }\n            lastBounds = bounds;\n          }\n          if (j < words.length || endsWithSpace) {\n            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\n          }\n        }\n      }\n      element.removeChild(curNode);\n      ignoredPreviousSibling = 0;\n    } else if (curNode.nodeType === 1) {\n      if (ignore && ignore.indexOf(curNode) > -1) {\n        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\n        ignoredPreviousSibling = curNode;\n      } else {\n        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\n        ignoredPreviousSibling = 0;\n      }\n      prepForCharsOnly && _disallowInline(curNode);\n    }\n  }\n};\nconst _SplitText = class _SplitText {\n  constructor(elements, config) {\n    this.isSplit = false;\n    _initIfNecessary();\n    this.elements = _elements(elements);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.masks = [];\n    this.vars = config;\n    this._split = () => this.isSplit && this.split(this.vars);\n    let orig = [], timerId, checkWidths = () => {\n      let i = orig.length, o;\n      while (i--) {\n        o = orig[i];\n        let w = o.element.offsetWidth;\n        if (w !== o.width) {\n          o.width = w;\n          this._split();\n          return;\n        }\n      }\n    };\n    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\n      clearTimeout(timerId);\n      timerId = setTimeout(checkWidths, 200);\n    }) };\n    _context(this);\n    this.split(config);\n  }\n  split(config) {\n    this.isSplit && this.revert();\n    this.vars = config = config || this.vars || {};\n    let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\n    if (splitCharacters || splitWords || splitLines) {\n      this.elements.forEach((element, index) => {\n        orig[index] = {\n          element,\n          html: element.innerHTML,\n          ariaL: element.getAttribute(\"aria-label\"),\n          ariaH: element.getAttribute(\"aria-hidden\")\n        };\n        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\n        let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\n        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\n        if (splitLines) {\n          let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;\n          for (i = 0; i < nodes.length; i++) {\n            curNode = nodes[i];\n            if (curNode.nodeType === 1) {\n              if (curNode.nodeName === \"BR\") {\n                toRemove.push(curNode);\n                wrapLine(lineStartIndex, i + 1);\n                lineStartIndex = i + 1;\n                lastBounds = allBounds[lineStartIndex];\n              } else {\n                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\n                  wrapLine(lineStartIndex, i);\n                  lineStartIndex = i;\n                }\n                lastBounds = allBounds[i];\n              }\n            }\n          }\n          lineStartIndex < i && wrapLine(lineStartIndex, i);\n          toRemove.forEach((el) => {\n            var _a;\n            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\n          });\n        }\n        if (!splitWords) {\n          for (i = 0; i < words.length; i++) {\n            curWord = words[i];\n            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\n              if (smartWrap && !splitLines) {\n                smartWrapSpan = document.createElement(\"span\");\n                smartWrapSpan.style.whiteSpace = \"nowrap\";\n                while (curWord.firstChild) {\n                  smartWrapSpan.appendChild(curWord.firstChild);\n                }\n                curWord.replaceWith(smartWrapSpan);\n              } else {\n                curWord.replaceWith(...curWord.childNodes);\n              }\n            } else {\n              nextSibling = curWord.nextSibling;\n              if (nextSibling && nextSibling.nodeType === 3) {\n                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\n                curWord.remove();\n              }\n            }\n          }\n          words.length = 0;\n          element.normalize();\n        }\n        this.lines.push(...lines);\n        this.words.push(...words);\n        this.chars.push(...chars);\n      });\n      mask && this[mask] && this.masks.push(...this[mask].map((el) => {\n        let maskEl = el.cloneNode();\n        el.replaceWith(maskEl);\n        maskEl.appendChild(el);\n        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\n        maskEl.style.overflow = \"clip\";\n        return maskEl;\n      }));\n    }\n    this.isSplit = true;\n    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\n    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\n      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\n    }\n    splitLines && autoSplit && this.elements.forEach((element, index) => {\n      orig[index].width = element.offsetWidth;\n      obs && obs.observe(element);\n    });\n    return this;\n  }\n  revert() {\n    var _a, _b;\n    let { orig, anim, obs } = this._data;\n    obs && obs.disconnect();\n    orig.forEach(({ element, html, ariaL, ariaH }) => {\n      element.innerHTML = html;\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\n    });\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\n    this.isSplit = false;\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\n    if (anim) {\n      this._data.animTime = anim.totalTime();\n      anim.revert();\n    }\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\n    return this;\n  }\n  static create(elements, config) {\n    return new _SplitText(elements, config);\n  }\n  static register(core) {\n    gsap = gsap || core || window.gsap;\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _context = gsap.core.context || _context;\n    }\n    if (!_coreInitted && window.innerWidth > 0) {\n      _fonts = document.fonts;\n      _coreInitted = true;\n    }\n  }\n};\n_SplitText.version = \"3.13.0\";\nlet SplitText = _SplitText;\n\nexport { SplitText, SplitText as default };\n","import gsap from 'gsap'\nimport SplitText from 'gsap/SplitText'\nimport ScrollTrigger from 'gsap/ScrollTrigger'\n\ngsap.registerPlugin(SplitText)\ngsap.registerPlugin(ScrollTrigger)\n\n/**\n *\n * @param {NodeListOf<HTMLElement>} textsElements\n */\nexport default function (textsElements) {\n  Array.from(textsElements).forEach((textElement) => {\n    const split = SplitText.create(textElement, {\n      autoSplit: true,\n      type: 'lines',\n      mask: 'lines',\n      onSplit: (self) => {\n        return gsap.from(self.lines, {\n          scrollTrigger: {\n            trigger: textElement,\n            start: 'top bottom',\n            end: 'bottom bottom',\n            toggleActions: 'play none none reset',\n          },\n          yPercent: 100,\n          stagger: 0.05,\n        })\n      },\n    })\n  })\n}\n"],"names":["gsap","_fonts","_coreInitted","_charSegmenter","Intl","Segmenter","_toArray","r","document","querySelectorAll","Array","from","_elements","targets","filter","e","HTMLElement","_emptyArray","_context","_spacesRegEx","_emojiSafeRegEx","RegExp","_emptyBounds","left","top","width","height","_stretchToFitSpecialChars","collection","specialCharsRegEx","slots","word","char","combined","charsFound","Set","join","match","i","length","size","startsWith","splice","_disallowInline","element","window","getComputedStyle","display","style","_insertNodeBefore","newChild","parent","existingChild","insertBefore","createTextNode","_getWrapper","type","config","className","tag","aria","propIndex","incrementClass","indexOf","wrapper","text","el","createElement","setProperty","setAttribute","position","textContent","push","replace","_splitWordsAndCharsRecursively","wordWrapper","charWrapper","prepForCharsOnly","deepSlice","ignore","charSplitRegEx","isNested","_a","wordDelimIsNotSpace","wordDelimString","wordDelimSplitter","curNode","words","curWordEl","startsWithSpace","endsWithSpace","j","bounds","curWordChars","clonedNode","curSubNode","tempSubNode","curTextContent","wordText","lastWordText","k","nodes","childNodes","wordDelimiter","reduceWhiteSpace","prepareText","elementBounds","getBoundingClientRect","lastBounds","isPreformatted","whiteSpace","substring","ignoredPreviousSibling","wordsCollection","delimiter","replaceWith","nodeType","split","slice","pop","charAt","shift","previousSibling","remove","parentNode","appendChild","firstChild","segment","map","s","cloneNode","nextSibling","removeChild","_SplitText","constructor","elements","this","isSplit","SplitText","register","chars","lines","masks","vars","_split","timerId","orig","checkWidths","o","w","offsetWidth","_data","obs","ResizeObserver","clearTimeout","setTimeout","revert","onSplitResult","smartWrap","onSplit","autoSplit","specialChars","mask","splitLines","splitCharacters","splitWords","onlySplitCharacters","finalCharSplitRegEx","source","animTime","forEach","index","html","innerHTML","ariaL","getAttribute","ariaH","trim","curWord","smartWrapSpan","wrapLine","lineWrapper","textAlign","startIndex","endIndex","newLine","normalize","_getLineWrapper","toRemove","lineStartIndex","allBounds","n","nodeName","maskEl","overflow","addEventListener","status","totalTime","anim","observe","_b","disconnect","removeAttribute","removeEventListener","onRevert","call","create","core","utils","toArray","context","innerWidth","fonts","version","splitText","textsElements","textElement","self","scrollTrigger","trigger","start","end","toggleActions","yPercent","stagger","registerPlugin","ScrollTrigger"],"mappings":"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","x_google_ignoreList":[0]}